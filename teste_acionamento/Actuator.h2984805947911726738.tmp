#ifndef ACTUATOR_H
#define ACTUATOR_H
#include <Arduino_FreeRTOS.h>
#include <SoftwareSerial.h>
#include "MyExceptions.h"
#include "TriggersAndCMs.h"
#define ACTPINSLEN 5
//#define ADDNEWACTS(acts, tps, dumLen, actLen, add) {  if (add) {    for (int i = 0, k = dumLen; i < k; i++) {      switch (tps[i]) {        case 'm': acts[actLen + i] = new RSpring(getActPins());          acts[actLen + i]->setup();acts[actLen + i]->setID(actLen+i);          Serial.println("->M");         break;        case 'v': acts[actLen + i] = new DSolenoid(getActPins());          acts[actLen + i]->setup(); acts[actLen + i]->setID(actLen+i);        Serial.println("->V");         break;      } dumLen -= 1;      actLen += 1;    } add = false;  }}
//

//using namespace my_execeptions;
using namespace trs_and_cms;
SoftwareSerial hc06(10, 11);/* RX pino 11 , TX pino 10 */


namespace aciones {
struct ActPins {
  uint8_t id;
  uint8_t py1; uint8_t py2;
  uint8_t ps1; uint8_t ps2;
  bool used;
};
ActPins actpins[ACTPINSLEN];
void initActPins() {
  for (int i = 0, k = 22; i < ACTPINSLEN; i++) {
    actpins[i].id = i;
    actpins[i].used = false;
    actpins[i].py1 = k++;
    actpins[i].py2 = k++;
    actpins[i].ps1 = k++;
    actpins[i].ps2 = k++;
  }
}
ActPins* getActPins() {
  ActPins* ptr;
  for (int i = 0; i < ACTPINSLEN; i++) {
    if (!actpins[i].used) {
      ptr = &actpins[i];
      actpins[i].used = true;
      break;
    }
  }
  return ptr;
}
//ActPins* getActPins(int i) {
//  ActPins* ptr;
//  --i;
//  if (!actpins[i].used && i < ACTPINSLEN) {
//    ptr = &actpins[i];
//  }
//  return ptr;
//}
class Actuator {
  public:
    virtual void setup() = 0;
    virtual void advance() =  0;
    virtual void retreat() =   0;
    virtual void turnAllOff() = 0;
    virtual void update() =   0;
    virtual void readS() = 0;
    void setID(int i) {
      this->id = i;
    }
    void setActuatorTriggerType(uint8_t tt) {
      if (tt < NOTRIGGER || tt > TEN) {
        Serial.println("Não é um tipo de trigger.");
      } else {
        this->actuateTriggerType = tt;
      }
    }
    void setActuatorTrigger(void *tr) {
      this->actuateTrigger = tr;
    }
    void setActuatorTrigger(int tr) {
      this->actTrigCountTgt = tr;
    }
    void actuate() {
      switch (this->actuateTriggerType) {
        case NOTRIGGER:
          break;
        case TCN:
          if (*(char*)this->actuateTrigger == ADVANCE) {
            this->advance();
          } else if (*(char*)this->actuateTrigger == RETREAT) {
            this->retreat();
          } else if (*(char*)this->actuateTrigger == TURNOFF) {
            this->turnAllOff();
          }
          break;
        case TSN:
          if (*(bool*)this->actuateTrigger) {
            this->advance();
          } else {
            this->retreat();
          }
          break;
        case TAN:
        case TRN:
          if ((*(int*)this->actuateTrigger) % this->actTrigCountTgt == 0) {
            this->advance();
          } else {
            this->retreat();
          }
          break;
      }

      this->timer();
      this->update();
    }
    void timer() {
      switch (this->timerTriggerType) {
        case NOTRIGGER: break;
        case TCN:
          switch (*(char*)this->timerTrigger) {
            case TIMERON:
              //xTaskDelayUntil(&this->xLastWakeTime, pdMS_TO_TICKS(this->timerdelay));
              delay(this->timerdelay);
              //this->timerCMD = NULL;
              break;
            case TIMEROFF:
              //this->timerCMD = NULL;
              break;
          }
        case TSN:
          if (*(bool*)this->timerTrigger) {
            //xTaskDelayUntil(&this->xLastWakeTime, pdMS_TO_TICKS(this->timerdelay));
            delay(this->timerdelay);
          }
          break;
        case TRN:
        case TAN:
          if (*(int*)this->timerTrigger % this->timerTrigCountTgt == 0) {
            //xTaskDelayUntil(&this->xLastWakeTime, pdMS_TO_TICKS(this->timerdelay));
            delay(this->timerdelay);
          }
          break;
        default:
          break;
      }
    }
    void setTimer(int t) {
      this->xLastWakeTime = xTaskGetTickCount ();
      this->timerdelay = t;
    }
    void setTimerTriggerType(uint8_t tt) {
      if (tt < NOTRIGGER || tt > TEN) {
        Serial.println("Não é um tipo de trigger.");
      } else {
        this->timerTriggerType = tt;
      }
    }
    void setTimerTrigger(void *trigger) {
      //define o gatilho para ativar o timer
      //podendo ser os sensores de fim de curso
      //do próprio atuador, de outros atuadores
      //ou de um sensor externo
      this->timerTrigger = trigger;
    }
    void setTimerTrigger(int trigger) {
      this->timerTrigCountTgt = trigger;
    }

    char getType() {
      return this->type;
    }
    int      getID  () {
      return this->id;
    }
    //****
    uint8_t getPY1  () {
      return this->actps->py1;
    }
    uint8_t getPY2 () {
      return this->actps->py2;
    }
    bool getY1  () {
      return this->y1;
    }
    bool getY2 () {
      return this->y2;
    }
    bool* giveY1  () {
      return &this->y1;
    }
    bool* giveY2  () {
      return &this->y2;
    }
    //****
    uint8_t getPS1 () {
      return this->actps->ps1;
    }
    uint8_t getPS2 () {
      return this->actps->ps2;
    }
    bool getS1 () {
      return this->s1;
    }
    bool getS2 () {
      return this->s2;
    }
    bool* giveS1 () {
      return &this->s1;
    }
    bool* giveS2 () {
      return &this->s2;
    }
    int* giveCounterA() {
      return &this->counterA;
    }
    int* giveCounterR() {
      return &this->counterR;
    }
    //****
    uint8_t getActuatorTrigType  () {
      return this->actuateTriggerType;
    }
    uint8_t getTimerTrigType() {
      return this->actuateTriggerType;
    }
    //****
    Actuator* giveThis() {
      return this;
    }
  protected:
    int id;//
    char type;
    int counterA, counterR; int actTrigCountTgt;
    ActPins* actps;
    bool y1, y2;
    uint8_t ps1, ps2;
    bool s1, s2;
    int timerdelay; int timerTrigCountTgt;
    TickType_t xLastWakeTime;
    uint8_t timerTriggerType;  void *timerTrigger;
    uint8_t actuateTriggerType; void *actuateTrigger;
};
class RSpring : public Actuator {
  public:
    RSpring(ActPins* p) {
      this->actps = p;
      this->type = 'M';
      //this->actps->used = true;
      //      this->py1 = py1; // pinos dos solenóides
      this->y1 = 0; this->y2 = 0;      // estados dos solenóides
      //      this->ps1 = ps1; this->ps2 = ps2;// pinos dos indicadores de fim de curso
      this->s1 = 1; this->s2 = 0;      // estados dos indicadores de fim curso
      // assumo que a posição inicial seja s1
      this->timerTriggerType = 0;
      this->timerdelay       = 0;
      this->actuateTriggerType = 0;
      this->counterA = 0; this->counterR = 0;
    }
    //    ~RSpring() {
    //      this->turnAllOff();
    //      this->actps->used = false;
    //    }
    void setup() {
      pinMode(this->actps->py1, OUTPUT);
      pinMode(this->actps->ps1, INPUT);
      pinMode(this->actps->ps2, INPUT);
      this->readS();
    }
    void readS() {
      this->s1 = digitalRead(this->actps->ps1);
      this->s2 = digitalRead(this->actps->ps2);
      if (this->s1 && this->s2) {
        Serial.println("Há algo de errado com os sensores de fim de curso!");
        hc06.write(ALERT);
      }
      if (/*this->s1*/this->y1 && this->counterA != this->counterR) { //00,01,11,12...
        counterA++;
      }
      else if (/*this->s2*/!(this->y1) && this->counterA == this->counterR) {
        counterR++;
      }
    }
    void advance() {
      this->y1 = 1;
    }
    void retreat() {
      this->y1 = 0;
    }
    void turnAllOff() {
      this->y1 = 0;
    }
    void update() {
      this->readS();
      digitalWrite(this->actps->py1, this->y1);
    }
};
class DSolenoid : public Actuator {
  public:
    DSolenoid(ActPins* p) {
      this->actps = p;
      this->type = 'V';
      //this->actps->used = true;
      //      this->py1 = py1; this->py2 = py2;// pinos dos solenóides
      this->y1 = 0; this->y2 = 0;      // estados dos solenóides
      //      this->ps1 = ps1; this->ps2 = ps2;// pinos dos indicadores de fim de curso
      this->s1 = 1; this->s2 = 0;      // estados dos indicadores de fim curso
      // assumo que a posição inicial seja s1
      this->timerTriggerType = 0;
      this->timerdelay       = 0;
      this->actuateTriggerType = 0;
      this->counterA = 0; this->counterR = 0;
    }

    void setup() {
      pinMode(this->actps->ps1, INPUT);
      pinMode(this->actps->ps2, INPUT);
      pinMode(this->actps->py1, OUTPUT);
      pinMode(this->actps->py2, OUTPUT);
      this->readS();
    }
    void readS() {
      //      Serial.print("\ny1 = " + String(this->y1) + ", y2 = " + String(this->y2));
      //      Serial.print("\n Comando: " + String(*(char*)this->actuateTrigger));
      this->s1 = digitalRead(this->actps->ps1);
      this->s2 = digitalRead(this->actps->ps2);
      //      if (this->s1 && this->s2) {
      //        Serial.println("Há algo de errado com os sensores de fim de curso!");
      //        hc06.write(ALERT);
      //      }
      if (/*this->s1*/this->y1 && this->counterA != this->counterR) { //00,01,11,12...
        counterA++;
      }
      if (/*this->s2*/this->y2 && this->counterA == this->counterR) {
        counterR++;
      }
    }
    void advance() {
      this->y1 = 1;
      this->y2 = 0;
    }
    void retreat() {
      this->y1 = 0;
      this->y2 = 1;
    }
    void turnAllOff() {
      this->y1 = 0;
      this->y2 = 0;
    }
    void update() {
      this->readS();
      digitalWrite(this->actps->py1, this->y1);
      digitalWrite(this->actps->py2, this->y2);
    }

};
Actuator* getActuatorByID(Actuator** acts, int actLen, int id) {
  Actuator* ptr;
  if ((id < actLen) && (id >= 0)) {
    for (int i = 0; i < actLen; i++) {
      if (acts[i]->getID() == id) {
        ptr = acts[i];
        Serial.println("Atuador " + String(ptr->getID()) + " encontrado.");
      }
    }
  } else {
    Serial.println("Atuador " + String(id) + " não encontrado.");
    ptr = NULL;
  }
  return ptr;
}
void ADDNEWACTS(Actuator** acts, char tps[], int& dumLen, void** actAdress, int& actLen, bool& create) {             //
  if (create) {
    for (int i = 0, k = dumLen; dumLen != 0; i++) {
      switch (tps[i]) {
        case 'm':
          Serial.println(actLen + i);
          acts[actLen + i] = new RSpring(getActPins());
          acts[actLen + i]->setup();
          acts[actLen + i]->setID(actLen + i);
          dumLen -= 1;
          actLen += 1;
          Serial.println("->M");
          break;
        case 'v':
          acts[actLen + i] = new DSolenoid(getActPins());
          acts[actLen + i]->setup();
          acts[actLen + i]->setID(actLen + i);
          if (acts[0]->getID() != 0) {
            Serial.println("Erro!");
          }
          dumLen -= 1;
          actLen += 1;
          Serial.println("->V");
          break;
        default:
          Serial.println("Lista de dummies:");
          for (int i = 0; i < k; i++) {
            Serial.print(tps[i]);
          }
          Serial.println();
          break;
      }
      actAdress[actLen+i] = acts[actLen + i]->giveThis();
      for (int i = 0; i < actLen; i++) {
        //            Serial.print((int)actuators[i]->giveThis());
        //            Serial.print(" ");
        if (acts[i]->giveThis() != (Actuator*)actAdress[i]) {
          acts[i] = (Actuator*)actAdress[i];
        }
      }
    }

  } create = false;
}
}
#endif
